<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url(https://themes.googleusercontent.com/fonts/css?kit=DFQxm4rd7fRHgM9OTejWVT5Vho6BE7M80rHXEVKqXWegg2XYR88pwOsaJkfiF7cJu5e0vFtnyLdhsxviZUUN-U0KZVwUvSK-LyXz4qcE1hc);.lst-kix_list_2-6>li:before{content:"\0025a0   "}.lst-kix_list_2-7>li:before{content:"\0025a0   "}ol.lst-kix_list_1-0{list-style-type:none}.lst-kix_list_2-4>li:before{content:"\0025a0   "}.lst-kix_list_2-5>li:before{content:"\0025a0   "}.lst-kix_list_2-8>li:before{content:"\0025a0   "}ol.lst-kix_list_3-0{list-style-type:none}.lst-kix_list_3-0>li:before{content:"" counter(lst-ctn-kix_list_3-0,decimal) ". "}ul.lst-kix_list_5-7{list-style-type:none}ul.lst-kix_list_5-8{list-style-type:none}.lst-kix_list_3-1>li:before{content:"\0025cb   "}.lst-kix_list_3-2>li:before{content:"\0025a0   "}ul.lst-kix_list_5-5{list-style-type:none}ul.lst-kix_list_3-7{list-style-type:none}ul.lst-kix_list_5-6{list-style-type:none}ul.lst-kix_list_3-8{list-style-type:none}ol.lst-kix_list_3-0.start{counter-reset:lst-ctn-kix_list_3-0 0}ul.lst-kix_list_1-3{list-style-type:none}ul.lst-kix_list_3-1{list-style-type:none}.lst-kix_list_3-5>li:before{content:"\0025a0   "}ul.lst-kix_list_5-0{list-style-type:none}ul.lst-kix_list_1-4{list-style-type:none}ul.lst-kix_list_3-2{list-style-type:none}ul.lst-kix_list_1-1{list-style-type:none}.lst-kix_list_3-4>li:before{content:"\0025a0   "}ul.lst-kix_list_1-2{list-style-type:none}ul.lst-kix_list_5-3{list-style-type:none}ul.lst-kix_list_1-7{list-style-type:none}.lst-kix_list_3-3>li:before{content:"\0025a0   "}ul.lst-kix_list_3-5{list-style-type:none}ul.lst-kix_list_5-4{list-style-type:none}ul.lst-kix_list_1-8{list-style-type:none}ul.lst-kix_list_3-6{list-style-type:none}ul.lst-kix_list_5-1{list-style-type:none}ul.lst-kix_list_1-5{list-style-type:none}ul.lst-kix_list_3-3{list-style-type:none}ul.lst-kix_list_5-2{list-style-type:none}ul.lst-kix_list_1-6{list-style-type:none}ul.lst-kix_list_3-4{list-style-type:none}.lst-kix_list_3-8>li:before{content:"\0025a0   "}.lst-kix_list_4-0>li:before{content:"\0025cf   "}.lst-kix_list_4-1>li:before{content:"\0025cb   "}.lst-kix_list_3-6>li:before{content:"\0025a0   "}.lst-kix_list_3-7>li:before{content:"\0025a0   "}.lst-kix_list_4-4>li:before{content:"\0025a0   "}.lst-kix_list_4-3>li:before{content:"\0025a0   "}.lst-kix_list_4-5>li:before{content:"\0025a0   "}.lst-kix_list_4-2>li:before{content:"\0025a0   "}.lst-kix_list_4-6>li:before{content:"\0025a0   "}.lst-kix_list_5-0>li:before{content:"\0025cf   "}.lst-kix_list_4-8>li:before{content:"\0025a0   "}.lst-kix_list_5-3>li:before{content:"\0025a0   "}.lst-kix_list_4-7>li:before{content:"\0025a0   "}.lst-kix_list_5-2>li:before{content:"\0025a0   "}.lst-kix_list_5-1>li:before{content:"\0025cb   "}ul.lst-kix_list_4-8{list-style-type:none}.lst-kix_list_5-7>li:before{content:"\0025a0   "}ul.lst-kix_list_4-6{list-style-type:none}.lst-kix_list_5-6>li:before{content:"\0025a0   "}.lst-kix_list_5-8>li:before{content:"\0025a0   "}ul.lst-kix_list_2-8{list-style-type:none}ul.lst-kix_list_4-7{list-style-type:none}ul.lst-kix_list_4-0{list-style-type:none}ul.lst-kix_list_2-2{list-style-type:none}ul.lst-kix_list_4-1{list-style-type:none}.lst-kix_list_1-0>li:before{content:"" counter(lst-ctn-kix_list_1-0,decimal) ". "}ul.lst-kix_list_2-3{list-style-type:none}.lst-kix_list_5-4>li:before{content:"\0025a0   "}ul.lst-kix_list_2-0{list-style-type:none}ul.lst-kix_list_2-1{list-style-type:none}ul.lst-kix_list_4-4{list-style-type:none}.lst-kix_list_5-5>li:before{content:"\0025a0   "}ul.lst-kix_list_2-6{list-style-type:none}ul.lst-kix_list_4-5{list-style-type:none}.lst-kix_list_1-1>li:before{content:"\0025cb   "}.lst-kix_list_1-2>li:before{content:"\0025a0   "}ul.lst-kix_list_2-7{list-style-type:none}ul.lst-kix_list_4-2{list-style-type:none}ul.lst-kix_list_2-4{list-style-type:none}ul.lst-kix_list_4-3{list-style-type:none}ul.lst-kix_list_2-5{list-style-type:none}.lst-kix_list_1-3>li:before{content:"\0025a0   "}.lst-kix_list_1-4>li:before{content:"\0025a0   "}ol.lst-kix_list_1-0.start{counter-reset:lst-ctn-kix_list_1-0 0}.lst-kix_list_1-0>li{counter-increment:lst-ctn-kix_list_1-0}.lst-kix_list_3-0>li{counter-increment:lst-ctn-kix_list_3-0}.lst-kix_list_1-7>li:before{content:"\0025a0   "}.lst-kix_list_1-5>li:before{content:"\0025a0   "}.lst-kix_list_1-6>li:before{content:"\0025a0   "}li.li-bullet-0:before{margin-left:-18pt;white-space:nowrap;display:inline-block;min-width:18pt}.lst-kix_list_2-0>li:before{content:"\0025cf   "}.lst-kix_list_2-1>li:before{content:"\0025cb   "}.lst-kix_list_1-8>li:before{content:"\0025a0   "}.lst-kix_list_2-2>li:before{content:"\0025a0   "}.lst-kix_list_2-3>li:before{content:"\0025a0   "}ol{margin:0;padding:0}table td,table th{padding:0}.c22{color:#151516;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:24pt;font-family:"Google Sans";font-style:normal}.c18{color:#1b1c1d;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:24pt;font-family:"Google Sans";font-style:normal}.c5{color:#1b1c1d;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:18pt;font-family:"Google Sans";font-style:normal}.c2{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Google Sans Text";font-style:normal}.c0{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c23{color:#1b1c1d;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:14pt;font-family:"Google Sans";font-style:normal}.c19{margin-left:23.2pt;padding-top:6pt;padding-bottom:6pt;line-height:1.149999976158142;padding-left:0pt;text-align:left}.c7{margin-left:24pt;padding-top:0pt;padding-bottom:6pt;line-height:1.149999976158142;padding-left:0pt;text-align:left}.c14{margin-left:24pt;padding-top:6pt;padding-bottom:6pt;line-height:1.149999976158142;padding-left:0pt;text-align:left}.c6{text-decoration:none;vertical-align:baseline;font-size:11pt;font-style:normal}.c20{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c1{font-family:"Google Sans Text";font-style:italic;color:#1b1c1d;font-weight:400}.c10{padding-top:12pt;padding-bottom:0pt;line-height:1.149999976158142;text-align:left}.c9{padding-top:0pt;padding-bottom:0pt;line-height:1.149999976158142;text-align:left}.c15{padding-top:12pt;padding-bottom:12pt;line-height:1.149999976158142;text-align:left}.c3{padding-top:0pt;padding-bottom:12pt;line-height:1.149999976158142;text-align:left}.c11{padding-top:0pt;padding-bottom:6pt;line-height:1.149999976158142;text-align:left}.c4{color:#1b1c1d;font-weight:400;font-family:"Google Sans Text"}.c13{color:#1b1c1d;font-weight:400;font-family:"Google Sans"}.c17{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c8{color:#1b1c1d;font-weight:700;font-family:"Google Sans Text"}.c24{font-size:24pt;font-style:italic}.c16{padding:0;margin:0}.c21{margin-left:23.2pt;padding-left:0pt}.c12{height:11pt}.title{padding-top:24pt;color:#000000;font-weight:700;font-size:36pt;padding-bottom:6pt;font-family:"Arial";line-height:1.0;page-break-after:avoid;text-align:left}.subtitle{padding-top:18pt;color:#666666;font-size:24pt;padding-bottom:4pt;font-family:"Georgia";line-height:1.0;page-break-after:avoid;font-style:italic;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:12pt;color:#000000;font-weight:700;font-size:24pt;padding-bottom:12pt;font-family:"Arial";line-height:1.0;text-align:left}h2{padding-top:11.2pt;color:#000000;font-weight:700;font-size:18pt;padding-bottom:11.2pt;font-family:"Arial";line-height:1.0;text-align:left}h3{padding-top:12pt;color:#000000;font-weight:700;font-size:14pt;padding-bottom:12pt;font-family:"Arial";line-height:1.0;text-align:left}h4{padding-top:12.8pt;color:#000000;font-weight:700;font-size:12pt;padding-bottom:12.8pt;font-family:"Arial";line-height:1.0;text-align:left}h5{padding-top:12.8pt;color:#000000;font-weight:700;font-size:9pt;padding-bottom:12.8pt;font-family:"Arial";line-height:1.0;text-align:left}h6{padding-top:18pt;color:#000000;font-weight:700;font-size:8pt;padding-bottom:18pt;font-family:"Arial";line-height:1.0;text-align:left}</style></head><body class="c17 doc-content"><p class="c3 c12"><span class="c0"></span></p><h1 class="c20" id="h.p8ujq3ziv0h"><span class="c22">Py CH4 12 of 17 </span></h1><h1 class="c11"><span class="c13">The &quot;Study Bible&quot; of Python&#39;s Deepest Secret: How Functions </span><span class="c8 c24">Really</span><span class="c18">&nbsp;Get Their Data</span></h1><p class="c3 c12"><span class="c6 c13"></span></p><p class="c3 c12"><span class="c6 c13"></span></p><h2 class="c11"><span class="c5">Introduction: The Great Misconception</span></h2><p class="c3 c12"><span class="c6 c13"></span></p><p class="c3"><span class="c4">Welcome to this in-depth study. We begin with a central mystery, one that every programmer must solve. When you call a function, like my_function(x), what are you </span><span class="c1">actually</span><span class="c4">&nbsp;handing over? Is it the variable x itself? Is it a complete, fresh </span><span class="c1">copy</span><span class="c6 c4">&nbsp;of what&#39;s inside x? Or is it something else entirely? The answer is one of Python&#39;s most important, elegant, and powerful secrets.</span></p><p class="c3"><span class="c6 c4">To understand Python&#39;s choice, let&#39;s first explore the two classic methods used by other programming languages. Think of it as a spy story about a top-secret document.</span></p><p class="c3"><span class="c4">First, there is </span><span class="c8">pass-by-value</span><span class="c4">. This is the &quot;Paranoid Method.&quot; Imagine you have a critical, original document. Instead of giving it to your colleague, you walk to a photocopier, make a </span><span class="c1">complete copy</span><span class="c4">&nbsp;of the entire document, and hand them that copy. They can take that photocopy, write all over it, spill coffee on it, even set it on fire. It makes no difference to you. Your </span><span class="c1">original</span><span class="c6 c4">&nbsp;document is safe and sound in your hands. This is very safe, but as we&#39;ll see, it can be incredibly inefficient.</span></p><p class="c3"><span class="c4">Second, there is </span><span class="c8">pass-by-reference</span><span class="c4">. This is the &quot;Trusting Method.&quot; Instead of making a copy, you give your colleague the </span><span class="c1">actual key</span><span class="c4">&nbsp;and the </span><span class="c1">office number</span><span class="c4">&nbsp;where the </span><span class="c1">one and only original document</span><span class="c4">&nbsp;is stored. They can now go into that office and... </span><span class="c1">oh no</span><span class="c4">... they can </span><span class="c1">change</span><span class="c6 c4">&nbsp;your original. They can add pages, cross things out, and you will see those changes because you both share that single, original file. This method is very fast (no copying!), but it can be dangerous.</span></p><p class="c3"><span class="c6 c4">This poses our central question: Which method does Python use? The safe-but-slow one, or the fast-but-dangerous one? As it turns out, Python does something much, much smarter.</span></p><p class="c3 c12"><span class="c6 c4"></span></p><h2 class="c11"><span class="c5">Chapter 1: The Python Way (And Why It&#39;s So Smart)</span></h2><p class="c3 c12"><span class="c6 c13"></span></p><p class="c3"><span class="c4">Python uses a method that some people call </span><span class="c8">pass-by-object-reference</span><span class="c6 c4">.</span></p><p class="c3"><span class="c6 c4">Let&#39;s update our analogy. This is neither giving a full, thousand-page photocopy nor giving the master key to the office.</span></p><p class="c3"><span class="c4">Instead, Python&#39;s method is like </span><span class="c1">texting someone the street address</span><span class="c4">&nbsp;of the building where the document is stored. You are sending a </span><span class="c1">copy</span><span class="c4">... but not a copy of the </span><span class="c1">whole building</span><span class="c4">. You are just sending a </span><span class="c1">copy of the reference</span><span class="c4">&nbsp;(the address). Now, you and your function both have the </span><span class="c1">same address</span><span class="c4">. You are both looking at the </span><span class="c1">same, single building</span><span class="c6 c4">&nbsp;from the outside.</span></p><p class="c3"><span class="c4">This is the entire secret. When a function call provides an argument, Python copies the argument object&#39;s </span><span class="c1">reference</span><span class="c6 c4">&mdash;not the object itself&mdash;into the corresponding parameter.</span></p><p class="c3"><span class="c4">But </span><span class="c1">why</span><span class="c4">&nbsp;do this? The answer is one word: </span><span class="c8">performance</span><span class="c6 c4">.</span></p><p class="c3"><span class="c4">This isn&#39;t just a minor technical detail; it is the </span><span class="c1">central reason</span><span class="c4">&nbsp;for this entire design. Python is a dominant language in fields like data science, artificial intelligence, and massive web services. In these fields, functions don&#39;t just manipulate the number 7; they manipulate </span><span class="c1">enormous</span><span class="c6 c4">&nbsp;objects&mdash;gigabytes of scientific data, huge website user databases, or complex machine learning models.</span></p><p class="c3"><span class="c4">Now, imagine if Python used the &quot;Paranoid Method&quot; (pass-by-value). Every time a function was called to analyze that data, Python would have to </span><span class="c1">copy</span><span class="c6 c4">&nbsp;that multi-gigabyte object. The program would grind to a halt, consuming vast amounts of memory and time. Python would be completely unusable for these high-performance tasks.</span></p><p class="c3"><span class="c6 c4">Pass-by-object-reference is the brilliant compromise. It&#39;s fast (like pass-by-reference) because you&#39;re only copying a tiny address. But, as we will see, it has a clever, built-in safety mechanism (unlike pass-by-reference) that protects your original data. This design is fundamental to Python&#39;s success.</span></p><p class="c3 c12"><span class="c6 c4"></span></p><h2 class="c11"><span class="c5">Chapter 2: Unlocking the Memory Model (The &quot;Signpost&quot; and the &quot;Treasure&quot;)</span></h2><p class="c3 c12"><span class="c6 c13"></span></p><p class="c3"><span class="c4">To grasp this, we must first correct the most common &quot;useful lie&quot; that new programmers are taught: that a variable is a &quot;box&quot; and when you type $x = 7$, you are putting the number 7 </span><span class="c1">inside</span><span class="c6 c4">&nbsp;the box labeled x.</span></p><p class="c3"><span class="c4">This is </span><span class="c1">not</span><span class="c6 c4">&nbsp;what happens. Understanding the truth is the key to mastering everything that follows.</span></p><p class="c3"><span class="c6 c4">Let&#39;s use a new analogy: the &quot;Signpost&quot; and the &quot;Treasure&quot;.</span></p><p class="c3"><span class="c6 c4">Imagine your computer&#39;s memory is a vast, sprawling city with billions of buildings, each with its own unique, secret address.</span></p><p class="c11"><span class="c6 c4">When you write the command $x = 7$:</span></p><ol class="c16 lst-kix_list_1-0 start" start="1"><li class="c7 li-bullet-0"><span class="c4">Python first builds a beautiful, immutable &quot;treasure chest.&quot; This is the </span><span class="c8">object</span><span class="c6 c4">. Inside this chest, it places the value 7.</span></li><li class="c14 li-bullet-0"><span class="c6 c4">It then places this treasure chest in a specific, empty building somewhere in the city of memory. Let&#39;s say it&#39;s at address 4350477840.</span></li><li class="c14 li-bullet-0"><span class="c4">Now, the variable x is </span><span class="c1">not</span><span class="c4">&nbsp;the treasure chest. The variable x is just a </span><span class="c8">signpost</span><span class="c6 c4">&nbsp;that you stick in the ground. And on that signpost, you write the address: 4350477840.</span></li></ol><p class="c15"><span class="c4">So, x </span><span class="c1">points to</span><span class="c4">&nbsp;(that is, references) the object; it does </span><span class="c1">not contain</span><span class="c6 c4">&nbsp;it. This distinction is the barrier between a beginner and an advanced Python programmer.</span></p><p class="c3 c12"><span class="c6 c4"></span></p><h2 class="c11"><span class="c5">Chapter 3: The Identity Code: Your First Detective Tool</span></h2><p class="c3 c12"><span class="c6 c13"></span></p><p class="c3"><span class="c6 c4">So, how can we prove any of this? How can we see the &quot;address&quot; written on the signpost?</span></p><p class="c3"><span class="c6 c4">The text gives us our first great detective tool: the built-in id() function.</span></p><p class="c3"><span class="c4">The id() function is like a fingerprint scanner. It doesn&#39;t tell you the </span><span class="c1">value</span><span class="c4">&nbsp;of the object (that&#39;s 7). Instead, it returns a </span><span class="c1">unique integer value</span><span class="c4">&nbsp;that identifies only </span><span class="c1">that specific object</span><span class="c4">&nbsp;while it remains in memory. This is the object&#39;s </span><span class="c8">identity</span><span class="c6 c4">.</span></p><p class="c3"><span class="c4">Think of it as the unique serial number for that specific treasure chest. Crucially, </span><span class="c1">no two objects in memory can have the same identity</span><span class="c6 c4">.</span></p><p class="c3"><span class="c6 c4">Let&#39;s walk through our first code example, as if we&#39;re typing it together.</span></p><p class="c9"><span class="c2">First, we start our investigation. We type:</span></p><p class="c9"><span class="c2">In : x = 7</span></p><p class="c3"><span class="c6 c4">This creates our treasure chest (the 7 object) and our signpost (x) pointing to its secret address.</span></p><p class="c9"><span class="c2">Now, let&#39;s use our new tool to read that address. We type:</span></p><p class="c9"><span class="c2">In : id(x)</span></p><p class="c9"><span class="c2">The output shown in the text is:</span></p><p class="c9"><span class="c2">Out: 4350477840</span></p><p class="c3"><span class="c4">Your number will almost certainly be different, and that&#39;s perfectly fine! The </span><span class="c1">value</span><span class="c6 c4">&nbsp;of the number doesn&#39;t matter. What matters is that this is our object&#39;s unique &quot;fingerprint.&quot; We have logged our first piece of evidence.</span></p><p class="c3 c12"><span class="c6 c4"></span></p><h2 class="c11"><span class="c5">Chapter 4: The Case of the Cube Function (The First Clue)</span></h2><p class="c3 c12"><span class="c6 c13"></span></p><p class="c3"><span class="c6 c4">Now, we&#39;ll set up our first experiment. Let&#39;s frame this as a detective story: we are going to send our variable into an &quot;interrogation room&quot; (a function) and see what happens.</span></p><p class="c9"><span class="c2">First, we define our interrogation room:</span></p><p class="c9"><span class="c2">In : def cube(number):</span></p><p class="c9"><span class="c2">Inside this function, we add a line to immediately &quot;check the fingerprint&quot; of whatever gets sent in:</span></p><p class="c9"><span class="c2">...: print(&#39;id(number):&#39;, id(number))</span></p><p class="c9"><span class="c2">And then, it just does its job and returns the value cubed:</span></p><p class="c9"><span class="c2">...: return number ** 3</span></p><p class="c9"><span class="c2">Now, the big moment. We are going to &quot;send&quot; our x into the room. We type:</span></p><p class="c9"><span class="c2">In : cube(x)</span></p><p class="c9"><span class="c2">What&#39;s the first thing that happens? The function prints the ID of its internal parameter, number. The output is:</span></p><p class="c9"><span class="c2">id(number): 4350477840</span></p><p class="c9"><span class="c2">Out: 343</span></p><p class="c3"><span class="c6 c4">Wait. Pause. Look at that number. 4350477840. Where have we seen that before?</span></p><p class="c3"><span class="c1">It&#39;s the exact same identity as our original x!</span><span class="c6 c4">.</span></p><p class="c3"><span class="c4">This is the &quot;smoking gun&quot; proof. Since every object has a unique identity, the fact that the </span><span class="c1">argument</span><span class="c4">&nbsp;x (our signpost) and the </span><span class="c1">parameter</span><span class="c4">&nbsp;number (the function&#39;s internal signpost) both report the same fingerprint proves they are pointing to the </span><span class="c1">exact same treasure chest</span><span class="c6 c4">.</span></p><p class="c3"><span class="c4">The function </span><span class="c1">did not</span><span class="c4">&nbsp;get a copy of the treasure chest. It got a </span><span class="c1">copy of the reference</span><span class="c4">&nbsp;(the address on the signpost), and now both variables, x and number, refer to the one and only </span><span class="c1">same object</span><span class="c6 c4">.</span></p><p class="c3 c12"><span class="c6 c4"></span></p><h2 class="c11"><span class="c5">Chapter 5: The &quot;is&quot; Operator: The Lie Detector</span></h2><p class="c3 c12"><span class="c6 c13"></span></p><p class="c3"><span class="c4">What if we&#39;re still skeptical? What if the id() function is just a strange coincidence? The text gives us a </span><span class="c1">second</span><span class="c6 c4">, even more direct tool: the is operator.</span></p><p class="c11"><span class="c6 c4">It&#39;s important to know the difference:</span></p><ul class="c16 lst-kix_list_2-0 start"><li class="c11 c21 li-bullet-0"><span class="c4">The == (double equals) operator checks if two objects have the </span><span class="c1">same value</span><span class="c6 c4">. For example, $a = 7 and $b = 7$, $a == b$ is True. It asks, &quot;do these two treasure chests both contain a 7?&quot;</span></li><li class="c19 li-bullet-0"><span class="c4">The is operator is a much stricter &quot;lie detector.&quot; It checks if two variables are </span><span class="c1">the exact same object</span><span class="c4">. It asks, &quot;are these two signposts pointing to the </span><span class="c1">exact same treasure chest</span><span class="c6 c4">?&quot;.</span></li></ul><p class="c10"><span class="c2">Let&#39;s modify our cube function to use this lie detector :</span></p><p class="c9"><span class="c2">In : def cube(number):</span></p><p class="c9"><span class="c2">This time, we&#39;ll print the result of the is check. Note that x is a global variable, so the function can see it to compare:</span></p><p class="c9"><span class="c2">...: print(&#39;number is x:&#39;, number is x)</span></p><p class="c9"><span class="c2">...: return number ** 3</span></p><p class="c9"><span class="c2">Now, let&#39;s run the test again:</span></p><p class="c9"><span class="c2">In : cube(x)</span></p><p class="c9"><span class="c2">The output is decisive:</span></p><p class="c9"><span class="c2">number is x: True</span></p><p class="c9"><span class="c2">Out: 343</span></p><p class="c3"><span class="c6 c4">The lie detector returns True. This is the final, undeniable proof. For the duration of that function call, the parameter number and the argument x are two different names for the exact same object. This confirms Python&#39;s pass-by-object-reference model.</span></p><p class="c3 c12"><span class="c6 c4"></span></p><h2 class="c11"><span class="c5">Chapter 6: The Plot Twist (The Case of the Unchangeable Object)</span></h2><p class="c3 c12"><span class="c6 c13"></span></p><p class="c3"><span class="c4">This is where our mystery gets truly intriguing, because our discovery creates a </span><span class="c1">huge</span><span class="c6 c4">&nbsp;paradox.</span></p><p class="c3"><span class="c4">&quot;But wait,&quot; you might ask. &quot;If the function&#39;s number parameter </span><span class="c1">is</span><span class="c4">&nbsp;the </span><span class="c1">original</span><span class="c4">&nbsp;x object... what happens if the function </span><span class="c1">changes</span><span class="c6 c4">&nbsp;number? Does that mean our original x will be changed forever? That sounds incredibly dangerous!&quot;</span></p><p class="c3"><span class="c6 c4">This is the great puzzle. And its solution lies in the nature of the object itself.</span></p><p class="c3"><span class="c4">Before we run the experiment, let&#39;s introduce a new analogy. Think of objects like integers (7), floats (15.5), and strings (&quot;hello&quot;) as </span><span class="c8">&quot;Engraved Stone Tablets&quot;</span><span class="c4">. The value 7 is </span><span class="c1">carved</span><span class="c4">&nbsp;into the stone. It </span><span class="c1">cannot</span><span class="c4">&nbsp;be changed. It is, by its very nature, </span><span class="c8">immutable</span><span class="c6 c4">&nbsp;(unmodifiable).</span></p><p class="c9"><span class="c2">Now, let&#39;s set up the final, critical experiment. We will redefine cube one last time to try to modify the object and watch what happens to its identity :</span></p><p class="c9"><span class="c2">In : def cube(number):</span></p><p class="c9"><span class="c2">First, we&#39;ll scan the ID before the attempted change:</span></p><p class="c9"><span class="c2">...: print(&#39;id(number) before modifying number:&#39;, id(number))</span></p><p class="c9"><span class="c2">Next, we&#39;ll try to change the value using an augmented assignment:</span></p><p class="c9"><span class="c2">...: number **= 3</span></p><p class="c9"><span class="c2">Then, we&#39;ll scan the ID after the attempted change:</span></p><p class="c9"><span class="c2">...: print(&#39;id(number) after modifying number:&#39;, id(number))</span></p><p class="c9"><span class="c2">And finally, we&#39;ll return the new value:</span></p><p class="c9"><span class="c2">...: return number</span></p><p class="c3"><span class="c6 c4">The stage is set. We have an immutable &quot;stone tablet&quot; (x pointing to 7). We have a function that is about to take a hammer and chisel to it. What will happen?</span></p><p class="c3 c12"><span class="c6 c4"></span></p><h2 class="c11"><span class="c5">Chapter 7: The &quot;New Object&quot; Revelation (A Study in Immutability)</span></h2><p class="c3 c12"><span class="c6 c13"></span></p><p class="c9"><span class="c2">This is the climax of our story. We hold our breath and type the command :</span></p><p class="c9"><span class="c2">In : cube(x)</span></p><p class="c11"><span class="c6 c4">Let&#39;s follow the execution, step-by-step :</span></p><ol class="c16 lst-kix_list_3-0 start" start="1"><li class="c7 li-bullet-0"><span class="c8">The Call Begins:</span><span class="c4">&nbsp;The function starts. Python copies the </span><span class="c1">reference</span><span class="c6 c4">&nbsp;from x into number. Both signposts point to the &quot;stone tablet&quot; 7 at address 4350477840.</span></li><li class="c14 li-bullet-0"><span class="c4">The First Output: The first print statement runs:</span><span class="c0"><br></span><span class="c4">id(number) before modifying number: 4350477840</span><span class="c0"><br></span><span class="c6 c4">This is just as we expected. The number parameter is, indeed, pointing to our original object.</span></li><li class="c14 li-bullet-0"><span class="c8">The &quot;Modification&quot;:</span><span class="c4">&nbsp;Now, the crucial line executes: $number **= 3$. Python calculates $7^3$, which is 343. It </span><span class="c1">tries</span><span class="c6 c4">&nbsp;to change the &quot;stone tablet.&quot; It tries to chisel away the 7 and carve 343 in its place.</span></li><li class="c14 li-bullet-0"><span class="c8">The Immutability Rule:</span><span class="c4">&nbsp;</span><span class="c1">But it can&#39;t!</span><span class="c4">&nbsp;The object is immutable. The &quot;stone tablet&quot; </span><span class="c1">refuses</span><span class="c6 c4">&nbsp;to be changed.</span></li><li class="c14 li-bullet-0"><span class="c8">The &quot;New Object&quot; Solution:</span><span class="c4">&nbsp;So what does Python do? It&#39;s a brilliant, simple solution. Since it can&#39;t modify the </span><span class="c1">old</span><span class="c4">&nbsp;tablet, it just... </span><span class="c1">creates a brand-new one</span><span class="c4">! It grabs a new, empty &quot;stone tablet&quot; (a new integer object), engraves 343 on it, and places it at a </span><span class="c1">completely new</span><span class="c6 c4">&nbsp;address in memory.</span></li><li class="c14 li-bullet-0"><span class="c8">The Reassignment:</span><span class="c4">&nbsp;Then, Python </span><span class="c1">reassigns its own, local parameter</span><span class="c4">&nbsp;number. It erases the old address on the number signpost and writes this </span><span class="c1">new</span><span class="c6 c4">&nbsp;address on it.</span></li><li class="c14 li-bullet-0"><span class="c4">The Second Output: The second print statement runs, and it reveals the plot twist:</span><span class="c0"><br></span><span class="c4">id(number) after modifying number: 4396653744</span><span class="c0"><br></span><span class="c6 c4">Out: 343</span></li></ol><p class="c15"><span class="c4">Look! The ID is </span><span class="c1">different</span><span class="c4">! It&#39;s a </span><span class="c1">new</span><span class="c6 c4">&nbsp;ID.</span></p><p class="c3"><span class="c4">This is the grand revelation that solves our paradox. The function </span><span class="c1">does</span><span class="c4">&nbsp;get a reference to the original object. But when it tries to </span><span class="c1">modify</span><span class="c4">&nbsp;that </span><span class="c1">immutable</span><span class="c4">&nbsp;object, Python </span><span class="c1">protects</span><span class="c4">&nbsp;it. It creates a </span><span class="c1">new</span><span class="c4">&nbsp;object for the result and re-points the function&#39;s </span><span class="c1">local</span><span class="c4">&nbsp;parameter to that </span><span class="c1">new</span><span class="c6 c4">&nbsp;object.</span></p><p class="c3"><span class="c4">The </span><span class="c1">original</span><span class="c6 c4">&nbsp;signpost (x) was never touched.</span></p><p class="c3 c12"><span class="c6 c4"></span></p><h2 class="c11"><span class="c5">Chapter 8: The Original Is Safe! (The &quot;Self-Check&quot; Confirmation)</span></h2><p class="c3 c12"><span class="c6 c13"></span></p><p class="c3"><span class="c6 c4">The function call is over. It returned the value 343. But what about our original variable, x? Is it safe? Did the function&#39;s internal drama have any effect on it?</span></p><p class="c9"><span class="c2">Let&#39;s check. We type:</span></p><p class="c9"><span class="c2">In : print(f&#39;x = {x}; id(x) = {id(x)}&#39;)</span></p><p class="c9"><span class="c2">The result is a sigh of relief:</span></p><p class="c9"><span class="c2">x = 7; id(x) = 4350477840</span></p><p class="c3"><span class="c4">Hallelujah! Our original x is perfectly safe. It&#39;s still 7, and it&#39;s still pointing to our original &quot;stone tablet&quot; object at the original address. The function&#39;s internal work had </span><span class="c1">no effect</span><span class="c4">&nbsp;on the caller&#39;s variable, </span><span class="c1">because</span><span class="c6 c4">&nbsp;the object was immutable.</span></p><p class="c3 c12"><span class="c6 c4"></span></p><h3 class="c11"><span class="c23">Test Your Knowledge</span></h3><p class="c3 c12"><span class="c6 c13"></span></p><p class="c3"><span class="c6 c4">Let&#39;s use the &quot;Self Check&quot; section from the text to lock in this new, deep understanding.</span></p><p class="c9"><span class="c2">1. Fill-in-the-Blank</span></p><p class="c9"><span class="c2">The built-in function _____ returns an object&rsquo;s unique identifier.</span></p><ul class="c16 lst-kix_list_4-0 start"><li class="c11 c21 li-bullet-0"><span class="c8">Answer and Explanation:</span><span class="c4">&nbsp;The answer is </span><span class="c8">id</span><span class="c4">. This is our &quot;fingerprint scanner.&quot; It&#39;s the tool that returns an object&#39;s unique integer </span><span class="c1">identity</span><span class="c6 c4">, which allows us to prove whether two variables are referencing the same object.</span></li></ul><p class="c10"><span class="c2">2. True/False</span></p><p class="c9"><span class="c2">Attempts to modify mutable objects create new objects.</span></p><ul class="c16 lst-kix_list_5-0 start"><li class="c11 c21 li-bullet-0"><span class="c8">Answer and Explanation:</span><span class="c4">&nbsp;This is </span><span class="c8">False</span><span class="c4">. This is a clever trick question! The text </span><span class="c1">just</span><span class="c4">&nbsp;taught us that attempts to modify </span><span class="c8">immutable</span><span class="c4">&nbsp;objects (like our &quot;stone tablet&quot; int or float) are what create new objects. The statement is false because, as we&#39;ll see, modifying </span><span class="c1">mutable</span><span class="c6 c4">&nbsp;objects does something very different.</span></li></ul><p class="c10"><span class="c2">3. The width Challenge (Narrated)</span></p><p class="c9"><span class="c2">Let&#39;s walk through the final IPython challenge, not as a table, but as a story that proves our point one last time.</span></p><p class="c9"><span class="c2">First, we create a new variable:</span></p><p class="c9"><span class="c2">In : width = 15.5</span></p><p class="c3"><span class="c4">Just like x = 7, the variable width is now a &quot;signpost&quot; pointing to an </span><span class="c1">immutable float object</span><span class="c4 c6">&mdash;another &quot;stone tablet,&quot; this one with 15.5 engraved on it.</span></p><p class="c9"><span class="c2">Next, we check its identity and value:</span></p><p class="c9"><span class="c2">In : print(&#39;id:&#39;, id(width), &#39; value:&#39;, width)</span></p><p class="c9"><span class="c2">Out: id: 4397553776 value: 15.5</span></p><p class="c3"><span class="c6 c4">We&#39;ve logged our evidence. The fingerprint is 4397553776.</span></p><p class="c9"><span class="c2">Now, we perform an operation that looks like a modification:</span></p><p class="c9"><span class="c2">In : width = width * 3</span></p><p class="c3"><span class="c4">What happens here? Just like in our cube function, Python calculates $15.5 * 3$, which is 46.5. Because the 15.5 object is an immutable &quot;stone tablet,&quot; Python </span><span class="c1">must</span><span class="c4">&nbsp;create a </span><span class="c1">brand-new</span><span class="c4">&nbsp;float object to hold the 46.5 result. It then </span><span class="c1">reassigns</span><span class="c4">&nbsp;the width signpost to point to this </span><span class="c1">new</span><span class="c6 c4">&nbsp;object.</span></p><p class="c9"><span class="c2">Finally, we check the variable again:</span></p><p class="c9"><span class="c2">In : print(&#39;id:&#39;, id(width), &#39; value:&#39;, width)</span></p><p class="c9"><span class="c2">Out: id: 4397554208 value: 46.5</span></p><p class="c3"><span class="c4">And there it is. The proof. The new id (4397554208) is </span><span class="c1">different</span><span class="c4">&nbsp;from the original (4397553776). This demonstrates, once and for all, that &quot;modifying&quot; an immutable variable doesn&#39;t change the object; it creates a </span><span class="c1">new</span><span class="c6 c4">&nbsp;object and reassigns the variable&#39;s reference to it.</span></p><p class="c3 c12"><span class="c6 c4"></span></p><h2 class="c11"><span class="c5">Conclusion: The Great &quot;Cliffhanger&quot; (The World of Mutable Objects)</span></h2><p class="c3 c12"><span class="c6 c13"></span></p><p class="c3"><span class="c4">We have been on an incredible journey. We have busted the &quot;variable-as-a-box&quot; myth and learned that variables are really &quot;signposts&quot; that hold </span><span class="c1">references</span><span class="c6 c4">&nbsp;(addresses) to objects.</span></p><p class="c3"><span class="c4">We&#39;ve discovered that Python&#39;s &quot;pass-by-object-reference&quot; system is a performance masterpiece, sending a </span><span class="c1">copy of the reference</span><span class="c6 c4">&nbsp;to a function, not a copy of the whole object.</span></p><p class="c3"><span class="c4">We&#39;ve used our detective tools, id() and is, to prove that a function&#39;s parameter and the caller&#39;s argument initially point to the </span><span class="c1">exact same object</span><span class="c6 c4">.</span></p><p class="c3"><span class="c4">And finally, we&#39;ve resolved the great paradox. We saw how our original variables are kept perfectly safe </span><span class="c1">because</span><span class="c4">&nbsp;their </span><span class="c8">immutable</span><span class="c4">&nbsp;&quot;stone tablet&quot; objects </span><span class="c1">refuse</span><span class="c4">&nbsp;to be changed, forcing the function to create </span><span class="c1">new</span><span class="c6 c4">&nbsp;objects for its own, local use.</span></p><p class="c3"><span class="c4">But... our entire safety net. Our whole &quot;the original is safe&quot; conclusion... it all depends on that one, single word: </span><span class="c1">immutable</span><span class="c6 c4">.</span></p><p class="c3"><span class="c4">What if the object </span><span class="c1">wasn&#39;t</span><span class="c6 c4">&nbsp;an &quot;Engraved Stone Tablet&quot;?</span></p><p class="c3"><span class="c4">What if it was a... &quot;Whiteboard&quot;? An object </span><span class="c1">designed</span><span class="c4">&nbsp;to be changed, erased, and written on? An object like... a </span><span class="c8">list</span><span class="c6 c4">?</span></p><p class="c3"><span class="c4">The text leaves us with this tantalizing, and slightly terrifying, cliffhanger. This is the &quot;what if&quot; that opens the door to the next level of Python mastery. As the text hints: &quot;In the next chapter, we&rsquo;ll show that when a reference to a </span><span class="c1">mutable</span><span class="c4">&nbsp;object like a list is passed to a function, the function </span><span class="c1">can</span><span class="c6 c4">&nbsp;modify the original object in the caller&quot;.</span></p><p class="c3"><span class="c4">That, my friend, is the power... and the danger... that awaits you in the </span><span class="c1">next</span><span class="c6 c4">&nbsp;part of your Study Bible.</span></p></body></html>
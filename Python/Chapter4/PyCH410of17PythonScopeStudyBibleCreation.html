<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url(https://themes.googleusercontent.com/fonts/css?kit=DFQxm4rd7fRHgM9OTejWVT5Vho6BE7M80rHXEVKqXWegg2XYR88pwOsaJkfiF7cJu5e0vFtnyLdhsxviZUUN-U0KZVwUvSK-LyXz4qcE1hc);.lst-kix_list_2-6>li:before{content:"\0025a0   "}.lst-kix_list_2-7>li:before{content:"\0025a0   "}ul.lst-kix_list_1-0{list-style-type:none}.lst-kix_list_2-4>li:before{content:"\0025a0   "}.lst-kix_list_2-5>li:before{content:"\0025a0   "}.lst-kix_list_2-8>li:before{content:"\0025a0   "}ol.lst-kix_list_2-0{list-style-type:none}ul.lst-kix_list_2-8{list-style-type:none}ul.lst-kix_list_1-3{list-style-type:none}ul.lst-kix_list_2-2{list-style-type:none}.lst-kix_list_1-0>li:before{content:"\0025cf   "}ul.lst-kix_list_1-4{list-style-type:none}ul.lst-kix_list_2-3{list-style-type:none}ul.lst-kix_list_1-1{list-style-type:none}ul.lst-kix_list_1-2{list-style-type:none}ul.lst-kix_list_2-1{list-style-type:none}ul.lst-kix_list_1-7{list-style-type:none}ul.lst-kix_list_2-6{list-style-type:none}.lst-kix_list_1-1>li:before{content:"\0025cb   "}.lst-kix_list_1-2>li:before{content:"\0025a0   "}ul.lst-kix_list_1-8{list-style-type:none}ol.lst-kix_list_2-0.start{counter-reset:lst-ctn-kix_list_2-0 0}ul.lst-kix_list_2-7{list-style-type:none}ul.lst-kix_list_1-5{list-style-type:none}ul.lst-kix_list_2-4{list-style-type:none}ul.lst-kix_list_1-6{list-style-type:none}ul.lst-kix_list_2-5{list-style-type:none}.lst-kix_list_1-3>li:before{content:"\0025a0   "}.lst-kix_list_1-4>li:before{content:"\0025a0   "}.lst-kix_list_2-0>li{counter-increment:lst-ctn-kix_list_2-0}.lst-kix_list_1-7>li:before{content:"\0025a0   "}.lst-kix_list_1-5>li:before{content:"\0025a0   "}.lst-kix_list_1-6>li:before{content:"\0025a0   "}li.li-bullet-0:before{margin-left:-18pt;white-space:nowrap;display:inline-block;min-width:18pt}.lst-kix_list_2-0>li:before{content:"" counter(lst-ctn-kix_list_2-0,decimal) ". "}.lst-kix_list_2-1>li:before{content:"\0025cb   "}.lst-kix_list_1-8>li:before{content:"\0025a0   "}.lst-kix_list_2-2>li:before{content:"\0025a0   "}.lst-kix_list_2-3>li:before{content:"\0025a0   "}ol{margin:0;padding:0}table td,table th{padding:0}.c13{color:#151516;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:24pt;font-family:"Google Sans";font-style:normal}.c6{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Google Sans Text";font-style:normal}.c12{color:#1b1c1d;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:14pt;font-family:"Google Sans";font-style:normal}.c11{color:#1b1c1d;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:18pt;font-family:"Google Sans";font-style:normal}.c0{color:#1b1c1d;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Google Sans Text";font-style:normal}.c14{color:#1b1c1d;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Google Sans";font-style:normal}.c17{color:#1b1c1d;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:24pt;font-family:"Google Sans";font-style:normal}.c22{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c18{text-decoration:none;vertical-align:baseline;font-size:11pt;font-style:normal}.c3{padding-top:0pt;padding-bottom:6pt;line-height:1.149999976158142;text-align:left}.c19{padding-top:12pt;padding-bottom:12pt;line-height:1.149999976158142;text-align:left}.c4{padding-top:0pt;padding-bottom:12pt;line-height:1.149999976158142;text-align:left}.c5{padding-top:0pt;padding-bottom:0pt;line-height:1.149999976158142;text-align:left}.c15{padding-top:6pt;padding-bottom:6pt;line-height:1.149999976158142;text-align:left}.c21{color:#000000;font-weight:400;font-family:"Arial"}.c20{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c1{color:#1b1c1d;font-weight:400;font-family:"Google Sans Text"}.c8{color:#1b1c1d;font-weight:700;font-family:"Google Sans Text"}.c9{margin-left:23.2pt;padding-left:0pt}.c16{padding:0;margin:0}.c10{margin-left:24pt;padding-left:0pt}.c7{height:11pt}.c2{font-style:italic}.title{padding-top:24pt;color:#000000;font-weight:700;font-size:36pt;padding-bottom:6pt;font-family:"Arial";line-height:1.0;page-break-after:avoid;text-align:left}.subtitle{padding-top:18pt;color:#666666;font-size:24pt;padding-bottom:4pt;font-family:"Georgia";line-height:1.0;page-break-after:avoid;font-style:italic;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:12pt;color:#000000;font-weight:700;font-size:24pt;padding-bottom:12pt;font-family:"Arial";line-height:1.0;text-align:left}h2{padding-top:11.2pt;color:#000000;font-weight:700;font-size:18pt;padding-bottom:11.2pt;font-family:"Arial";line-height:1.0;text-align:left}h3{padding-top:12pt;color:#000000;font-weight:700;font-size:14pt;padding-bottom:12pt;font-family:"Arial";line-height:1.0;text-align:left}h4{padding-top:12.8pt;color:#000000;font-weight:700;font-size:12pt;padding-bottom:12.8pt;font-family:"Arial";line-height:1.0;text-align:left}h5{padding-top:12.8pt;color:#000000;font-weight:700;font-size:9pt;padding-bottom:12.8pt;font-family:"Arial";line-height:1.0;text-align:left}h6{padding-top:18pt;color:#000000;font-weight:700;font-size:8pt;padding-bottom:18pt;font-family:"Arial";line-height:1.0;text-align:left}</style></head><body class="c20 doc-content"><p class="c4 c7"><span class="c18 c21"></span></p><h1 class="c22" id="h.2c6k6nk5p9dm"><span class="c13">Py CH4 10 of 17 </span></h1><h1 class="c3"><span class="c17">The Book of Scope: A Study Bible on Python&#39;s Rules of Visibility</span></h1><p class="c4 c7"><span class="c14"></span></p><p class="c4 c7"><span class="c14"></span></p><h2 class="c3"><span class="c11">Chapter 1: The Unseen Borders: What is Scope?</span></h2><p class="c4 c7"><span class="c14"></span></p><p class="c4"><span class="c0">In programming, a major challenge is managing complexity. If every name used in a program&mdash;every variable, every function&mdash;was accessible from everywhere else, the result would be chaos. It would be impossible to know if changing a variable in one part of the code would break an entirely different, unrelated part.</span></p><p class="c4"><span class="c0">This is why Python employs a set of rules known as &quot;scope.&quot; An identifier&#39;s scope is the specific region of a program where that identifier (a name for a variable or function) can be accessed and used. For the portion of the program where a name is valid, it is said to be &quot;in scope&quot;. This system acts as a &quot;need-to-know&quot; policy, creating &quot;unseen borders&quot; that keep code clean, manageable, and safe.</span></p><p class="c4"><span class="c1">Before exploring </span><span class="c1 c2">where</span><span class="c1">&nbsp;these borders are, it is essential to understand </span><span class="c1 c2">when</span><span class="c0">&nbsp;they are established. A Python script has two distinct phases of life, based on where the code is written.</span></p><p class="c4"><span class="c1">First is the &quot;setup phase,&quot; which involves statements at the global scope, meaning code written outside of any function. These &quot;script statements at global scope execute as soon as they&rsquo;re encountered by the interpreter&quot;. As the interpreter reads the file from top to bottom, it &quot;builds the world&quot; by defining global variables and registering the </span><span class="c1 c2">definitions</span><span class="c0">&nbsp;of functions.</span></p><p class="c4"><span class="c1">Second is the &quot;action phase.&quot; This involves the code </span><span class="c1 c2">inside</span><span class="c1">&nbsp;function blocks. This code is &quot;sleeping&quot; during the setup phase; its statements &quot;execute only when the function is called&quot;. This distinction is fundamental: the program&#39;s world is </span><span class="c1 c2">built</span><span class="c1">&nbsp;first, and only </span><span class="c1 c2">after</span><span class="c1">&nbsp;that do the </span><span class="c1 c2">actions</span><span class="c0">&nbsp;(function calls) within that world take place.</span></p><p class="c4 c7"><span class="c0"></span></p><h2 class="c3"><span class="c11">Chapter 2: The Two Realms: The Global Kingdom and the Local Village</span></h2><p class="c4 c7"><span class="c14"></span></p><p class="c4"><span class="c0">Python&#39;s scope rules primarily define two distinct &quot;realms&quot; or territories where names can live: the global scope and the local scope.</span></p><p class="c4 c7"><span class="c0"></span></p><h3 class="c3"><span class="c12">The Global Kingdom (Global Scope)</span></h3><p class="c4 c7"><span class="c14"></span></p><p class="c4"><span class="c0">The global scope is the vast, open &quot;kingdom&quot; of an entire .py file. Any identifier, such as a function or variable, that is &quot;defined outside any function (or class)&quot; is considered to have global scope. Variables defined here are known as global variables.</span></p><p class="c4"><span class="c1">A global variable is like a royal proclamation, visible to all. Any identifier with global scope &quot;can be used... anywhere after they&rsquo;re defined&quot;. This reinforces the top-to-bottom nature of the &quot;setup phase&quot; discussed in Chapter 1: the proclamation must be </span><span class="c1 c2">made</span><span class="c1">&nbsp;(the variable defined) before it can be </span><span class="c1 c2">read</span><span class="c0">&nbsp;by other parts of the kingdom.</span></p><p class="c4 c7"><span class="c0"></span></p><h3 class="c3"><span class="c12">The Local Village (Local Scope)</span></h3><p class="c4 c7"><span class="c14"></span></p><p class="c4"><span class="c0">In contrast, the local scope is a small, private, and temporary &quot;village.&quot; A function definition creates this walled-off territory. An identifier for a local variable has local scope, meaning it is &quot;in scope&quot; only from the point of its definition &quot;to the end of the function&rsquo;s block&quot;.</span></p><p class="c4"><span class="c1">This local scope is temporary and ephemeral. It is &quot;built&quot; when the function is called, and it is </span><span class="c1 c2">destroyed</span><span class="c0">&nbsp;when the function finishes. As the Self Check section confirms, &quot;Once a code block terminates (e.g., when a function returns), all identifiers defined in that block &#39;go out of scope&#39; and can no longer be accessed&quot;. The &quot;village&quot; and all its inhabitants (its local variables) simply vanish. This ephemeral nature makes local variables private and safe, as they cannot be seen or altered by any code outside the function.</span></p><p class="c4 c7"><span class="c0"></span></p><h2 class="c3"><span class="c11">Chapter 3: The View from the Village (A One-Way Mirror)</span></h2><p class="c4 c7"><span class="c14"></span></p><p class="c4"><span class="c0">What happens when these two realms interact? Specifically, what happens when code inside the &quot;local village&quot; (a function) needs to read a &quot;proclamation&quot; from the &quot;global kingdom&quot; (a global variable)?</span></p><p class="c4"><span class="c1">The system works like a one-way mirror: the village can see </span><span class="c1 c2">out</span><span class="c1">, but the kingdom cannot see </span><span class="c1 c2">in</span><span class="c0">.</span></p><p class="c4"><span class="c0">This is demonstrated by the access_global example. First, a global variable is defined in the &quot;kingdom&quot;:</span></p><p class="c4"><span class="c0">In : x = 7</span></p><p class="c4"><span class="c1">Next, a function, or &quot;village,&quot; is </span><span class="c1 c2">defined</span><span class="c0">&nbsp;(but not yet called). Its blueprint states that it should print the value of x:</span></p><p class="c5"><span class="c6">In : def access_global():</span></p><p class="c5"><span class="c6">...: print(&#39;x printed from access_global:&#39;, x)</span></p><p class="c4"><span class="c1">Finally, the function is </span><span class="c1 c2">called</span><span class="c0">, and the &quot;village&quot; comes to life:</span></p><p class="c4"><span class="c0">In : access_global()</span></p><p class="c4"><span class="c1">When the access_global function executes, it needs to find the value for the identifier x. It first looks </span><span class="c1 c2">inside its own walls</span><span class="c1">&nbsp;(its local scope). It does not find a local variable named x. Because no local x is found, Python&#39;s rules dictate that it then looks </span><span class="c1 c2">outside</span><span class="c0">&nbsp;its walls, up to the global scope.</span></p><p class="c4"><span class="c0">There, it &quot;sees&quot; the global x = 7. It successfully reads this value and prints it. The output confirms this one-way visibility:</span></p><p class="c4"><span class="c0">x printed from access_global: 7</span></p><p class="c4"><span class="c0">This confirms the rule: &quot;You can access a global variable&rsquo;s value inside a function&quot;.</span></p><p class="c4 c7"><span class="c0"></span></p><h2 class="c3"><span class="c11">Chapter 4: The Tale of Two &#39;x&#39;s (The Illusion of Change)</span></h2><p class="c4 c7"><span class="c14"></span></p><p class="c4"><span class="c1">The situation becomes far more intriguing when a function attempts to </span><span class="c1 c2">change</span><span class="c0">&nbsp;a global variable, not just read it. This scenario reveals a core protective-design principle in Python.</span></p><p class="c4"><span class="c0">The story continues with the global x still set to 7. A new function is defined, try_to_modify_global, which appears to assign a new value to x:</span></p><p class="c5"><span class="c6">In : def try_to_modify_global():</span></p><p class="c5"><span class="c6">...: x = 3.5</span></p><p class="c5"><span class="c6">...: print(&#39;x printed from try_to_modify_global:&#39;, x)</span></p><p class="c4"><span class="c1">When this function is called, it </span><span class="c1 c2">seems</span><span class="c0">&nbsp;to work. It prints a new value:</span></p><p class="c5"><span class="c6">In : try_to_modify_global()</span></p><p class="c5"><span class="c6">x printed from try_to_modify_global: 3.5</span></p><p class="c4"><span class="c0">This is the central &quot;mystery.&quot; It appears that the function has successfully changed x to 3.5. But this is an illusion.</span></p><p class="c4"><span class="c1">The &quot;reveal&quot; comes when the value of x is checked </span><span class="c1 c2">outside</span><span class="c0">&nbsp;the function, back in the global kingdom:</span></p><p class="c5"><span class="c6">In : x</span></p><p class="c5"><span class="c6">Out: 7</span></p><p class="c4"><span class="c0">The global x is completely unchanged. It was never touched. The &quot;attempt&quot; to modify it failed.</span></p><p class="c4"><span class="c1">What happened is a crucial concept called </span><span class="c8">shadowing</span><span class="c1">. The text explains: &quot;by default, you cannot modify a global variable in a function&mdash;when you first assign a value to a variable in a function&rsquo;s block, Python creates a </span><span class="c1 c2">new</span><span class="c0">&nbsp;local variable&quot;.</span></p><p class="c4"><span class="c1">This is not a bug, but a vital safety feature. Python </span><span class="c1 c2">assumes</span><span class="c1">&nbsp;that an assignment inside a function (like x = 3.5) is intended to create a </span><span class="c1 c2">new, private, local</span><span class="c0">&nbsp;variable. This default behavior protects the global scope from being &quot;polluted&quot; or &quot;corrupted&quot; by functions. It makes code modular, allowing functions to be written without fear of accidentally breaking a global variable that happens to share the same name.</span></p><p class="c4"><span class="c1">This new local x (with the value 3.5) acts as an &quot;impostor&quot; inside the function. This local x </span><span class="c8">shadows</span><span class="c1">&nbsp;the global x, &quot;making it inaccessible in the scope of the function&rsquo;s block&quot;. When try_to_modify_global is asked to &quot;print x,&quot; it sees its </span><span class="c1 c2">own</span><span class="c0">&nbsp;local x first and prints 3.5. The &quot;real&quot; global x (with the value 7) is hidden in the shadow, safe and untouched.</span></p><p class="c4 c7"><span class="c0"></span></p><h2 class="c3"><span class="c11">Chapter 5: The Royal Emissary (The &#39;global&#39; Keyword)</span></h2><p class="c4 c7"><span class="c14"></span></p><p class="c4"><span class="c1">Python&#39;s default behavior is to protect the global scope. But what if the programmer </span><span class="c1 c2">genuinely</span><span class="c1">&nbsp;and </span><span class="c1 c2">intentionally</span><span class="c0">&nbsp;wants a function to modify a global variable?</span></p><p class="c4"><span class="c1">For this, Python requires an </span><span class="c1 c2">explicit</span><span class="c0">&nbsp;declaration. The function must &quot;raise a flag&quot; to announce its intention. This is accomplished with the global keyword.</span></p><p class="c4"><span class="c0">Using the global keyword is like dispatching a &quot;royal emissary&quot; with the authority to change the &quot;king&#39;s proclamation.&quot; It overrides the default protective behavior.</span></p><p class="c4"><span class="c0">Let&#39;s observe the modify_global function. (Note: The global x is still 7 at this point in the execution trace from the original source) :</span></p><p class="c5"><span class="c6">In : def modify_global():</span></p><p class="c5"><span class="c6">...: global x</span></p><p class="c5"><span class="c6">...: x = &#39;hello&#39;</span></p><p class="c5"><span class="c6">...: print(&#39;x printed from modify_global:&#39;, x)</span></p><p class="c4"><span class="c1">The line global x is the &quot;oath of allegiance.&quot; It tells Python: &quot;The x I am about to use is </span><span class="c1 c2">not</span><span class="c0">&nbsp;a new local variable. I am referring to the one and only x in the global scope&quot;.</span></p><p class="c4"><span class="c1">Now, when the line x = &#39;hello&#39; executes, Python does not create a new local variable. It goes directly to the global scope and </span><span class="c1 c2">changes the value</span><span class="c0">&nbsp;of the global x.</span></p><p class="c4"><span class="c0">The execution and its aftermath prove this:</span></p><p class="c5"><span class="c6">In : modify_global()</span></p><p class="c5"><span class="c6">x printed from modify_global: hello</span></p><p class="c5"><span class="c6">In : x</span></p><p class="c5"><span class="c6">Out: &#39;hello&#39;</span></p><p class="c4"><span class="c1">The call to modify_global prints &#39;hello&#39;. More importantly, when x is checked in the global scope </span><span class="c1 c2">after</span><span class="c0">&nbsp;the function has returned, its value has been permanently changed to &#39;hello&#39;. The global keyword successfully provided the function with the necessary (and dangerous) permission to alter the global state.</span></p><p class="c4 c7"><span class="c0"></span></p><h2 class="c3"><span class="c11">Chapter 6: A Case of Stolen Identity (Shadowing Built-in Functions)</span></h2><p class="c4 c7"><span class="c14"></span></p><p class="c4"><span class="c1">The concept of &quot;shadowing&quot; has an even more dangerous application. We have seen a </span><span class="c1 c2">local</span><span class="c1">&nbsp;variable shadow a </span><span class="c1 c2">global</span><span class="c1">&nbsp;variable. An even more significant &quot;gotcha&quot; occurs when a </span><span class="c1 c2">global</span><span class="c1">&nbsp;variable shadows a </span><span class="c1 c2">built-in function</span><span class="c0">.</span></p><p class="c4"><span class="c0">Python comes with a library of &quot;built-in&quot; functions that are always available, such as print() and sum(). The text notes that when summing values, the variable total was used, not sum. The reason given is that &quot;sum is a built-in function&quot;. This hints at the danger.</span></p><p class="c4"><span class="c0">Consider the &quot;crime&quot; of a careless assignment:</span></p><p class="c4"><span class="c0">In : sum = 10 + 5</span></p><p class="c4"><span class="c1">This line creates a </span><span class="c1 c2">new global variable</span><span class="c0">&nbsp;with the name sum and assigns it the integer value 15.</span></p><p class="c5"><span class="c6">In : sum</span></p><p class="c5"><span class="c6">Out: 15</span></p><p class="c4"><span class="c1">The consequence of this action is severe. The original, built-in sum </span><span class="c1 c2">function</span><span class="c1">&nbsp;(the &quot;public servant&quot;) has been &quot;put out of a job.&quot; It is now &quot;shadowed&quot; by a new global </span><span class="c1 c2">integer</span><span class="c0">&nbsp;named sum.</span></p><p class="c4"><span class="c1">Later, when an attempt is made to use the </span><span class="c1 c2">real</span><span class="c0">&nbsp;sum function to add up a list, the program crashes:</span></p><p class="c5"><span class="c6">In : sum()</span></p><p class="c5"><span class="c6">-------------------------------------------------------------------------</span></p><p class="c5"><span class="c6">TypeError Traceback (most recent call last)</span></p><p class="c5"><span class="c6">...</span></p><p class="c5"><span class="c6">TypeError: &#39;int&#39; object is not callable</span></p><p class="c3"><span class="c0">The error message TypeError: &#39;int&#39; object is not callable is Python&#39;s cry for help.</span></p><ul class="c16 lst-kix_list_1-0 start"><li class="c3 c9 li-bullet-0"><span class="c1">&#39;int&#39; object: Python is saying, &quot;You are holding an </span><span class="c1 c2">integer</span><span class="c0">&nbsp;(the number 15).&quot;</span></li><li class="c15 c9 li-bullet-0"><span class="c0">is not callable: &quot;Callable&quot; is the word for something that can be &quot;called&quot; with parentheses (), like a function.</span></li><li class="c9 c15 li-bullet-0"><span class="c1">Translation: &quot;You are trying to </span><span class="c1 c2">use the number 15</span><span class="c1">&nbsp;as if it were a </span><span class="c1 c2">function</span><span class="c1">! A number cannot be </span><span class="c1 c2">called</span><span class="c0">!&quot;.</span></li></ul><p class="c19"><span class="c1">This reveals the &quot;chain&quot; of scope. When Python looks for a name, it looks in a specific order. The try_to_modify_global example showed that Python checks the </span><span class="c8">Local</span><span class="c1">&nbsp;scope </span><span class="c1 c2">before</span><span class="c1">&nbsp;the </span><span class="c8">Global</span><span class="c1">&nbsp;scope (the local x hid the global x). This sum example shows that Python checks the </span><span class="c8">Global</span><span class="c1">&nbsp;scope </span><span class="c1 c2">before</span><span class="c1">&nbsp;the </span><span class="c8">Built-in</span><span class="c0">&nbsp;scope (the global sum variable hid the built-in sum function). This hierarchical search (Local, then Global, then Built-in) is a fundamental, predictive rule of the Python language.</span></p><p class="c4 c7"><span class="c0"></span></p><h2 class="c3"><span class="c11">Chapter 7: The Final Secret: &#39;Blocks&#39; vs. &#39;Suites&#39;</span></h2><p class="c4 c7"><span class="c14"></span></p><p class="c4"><span class="c0">A final, subtle &quot;secret&quot; of scope is revealed in the distinction between function &quot;blocks&quot; and control statement &quot;suites&quot;.</span></p><p class="c4"><span class="c1">A function </span><span class="c8">block</span><span class="c1">&nbsp;is the indented code that follows a def statement. As established, &quot;When you create a variable in a block, it&rsquo;s </span><span class="c8">local</span><span class="c1">&nbsp;to that block&quot;. A def builds a </span><span class="c1 c2">true</span><span class="c0">&nbsp;new scope, a &quot;walled-off village.&quot;</span></p><p class="c4"><span class="c1">A control statement </span><span class="c8">suite</span><span class="c1">&nbsp;is the indented code that follows an if, for, or while statement. Here lies the twist: a suite does </span><span class="c1 c2">not</span><span class="c1">&nbsp;create a new scope. It is not a &quot;village,&quot; but merely a &quot;roped-off area&quot; </span><span class="c1 c2">within</span><span class="c0">&nbsp;the realm one is already in.</span></p><p class="c4"><span class="c0">The rule is: &quot;when you create a variable in a control statement&rsquo;s suite, the variable&rsquo;s scope depends on where the control statement is defined&quot;.</span></p><p class="c3"><span class="c0">This leads to two distinct scenarios:</span></p><ol class="c16 lst-kix_list_2-0 start" start="1"><li class="c3 c10 li-bullet-0"><span class="c8">The &quot;Global Rope-Off&quot;:</span><span class="c0">&nbsp;&quot;If the control statement is in the global scope, then any variables defined in the control statement have global scope&quot;. For example, if a for loop like for i in range(10): pass is written at the top level of a file (global scope), the variable i &quot;leaks out.&quot; It becomes a global variable, visible to the entire &quot;kingdom&quot; even after the loop is finished.</span></li><li class="c15 c10 li-bullet-0"><span class="c8">The &quot;Local Rope-Off&quot;:</span><span class="c1">&nbsp;&quot;If the control statement is in a function&rsquo;s block, then any variables defined in the control statement have local scope&quot;. If that same for i in range(10): pass is written </span><span class="c1 c2">inside</span><span class="c1">&nbsp;a function, the variable i is </span><span class="c1 c2">local</span><span class="c1">&nbsp;to that </span><span class="c1 c2">function</span><span class="c1">. It is &quot;roped-off&quot; </span><span class="c1 c2">within</span><span class="c0">&nbsp;the &quot;village.&quot; When the function returns, i vanishes along with the rest of the function&#39;s local variables.</span></li></ol><p class="c19"><span class="c1">This distinction reveals that Python&#39;s </span><span class="c1 c2">fundamental unit of scope is the function</span><span class="c0">&nbsp;(and the class, as hinted) , not just any indented set of brackets or &quot;block&quot; as in other languages like C++ or Java. Those languages &quot;trap&quot; loop variables inside the loop. Python does not. This is a critical design difference and a common &quot;gotcha&quot; for programmers migrating from other backgrounds.</span></p><p class="c4 c7"><span class="c0"></span></p><h2 class="c3"><span class="c11">Conclusion: The Catechism of Scope</span></h2><p class="c4 c7"><span class="c14"></span></p><p class="c4"><span class="c0">This journey through Python&#39;s scope rules can be synthesized by revisiting the &quot;Self Check&quot; catechism and answering with this deeper understanding.</span></p><p class="c4"><span class="c8 c18">Question 1: (FILL-IN) An identifier&rsquo;s _____ describes the region of a program in which the identifier&rsquo;s value can be accessed.</span></p><p class="c4"><span class="c1">The answer is </span><span class="c8">scope</span><span class="c1">. But it is now clear that this is more than a definition. Scope is the &quot;need-to-know&quot; policy, the set of &quot;borders&quot; that creates &quot;kingdoms&quot; (Global) and &quot;villages&quot; (Local). It is the protective mechanism that prevents chaos by </span><span class="c1 c2">defaulting</span><span class="c0">&nbsp;to private, local variables (Chapter 4), and it defines the search order (Local, then Global, then Built-in) that explains the sum mystery (Chapter 6).</span></p><p class="c4"><span class="c18 c8">Question 2: (TRUE/FALSE) Once a code block terminates (e.g., when a function returns), all identifiers defined in that block &ldquo;go out of scope&rdquo; and can no longer be accessed.</span></p><p class="c4"><span class="c1">The answer is </span><span class="c8">True</span><span class="c1">. This is the &quot;life and death&quot; of the &quot;local village.&quot; The function </span><span class="c1 c2">block</span><span class="c1">&nbsp;is the fundamental unit of scope (Chapter 7). When a function is called, the local scope is created. When the function </span><span class="c1 c2">returns</span><span class="c1">, that scope and </span><span class="c1 c2">all</span><span class="c1">&nbsp;identifiers within it&mdash;including variables created in loops </span><span class="c1 c2">within</span><span class="c0">&nbsp;that function&mdash;are destroyed. They &quot;go out of scope,&quot; making the local scope a private, temporary, and safe place to work.</span></p></body></html>